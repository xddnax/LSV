package main.java.lsv.core;

import main.java.lsv.model.Model;

import java.util.ArrayList;

import main.java.lsv.grammar.Formula;

class FormulaTreeNode {
	Formula currFormula;
	ArrayList<Formula> children = new ArrayList<Formula>();
	Formula parent;


	FormulaTreeNode(Formula curr, Formula par, ArrayList<Formula> children) {
		this.currFormula = curr;
		this.parent = par;
		this.children = children;

	}

}

class FormulaTree {
	FormulaTreeNode initNode;
	ArrayList<FormulaTreeNode> children = new ArrayList<FormulaTreeNode>();

	FormulaTree(FormulaTreeNode head) {
		this.initNode = head;
	}

	void addFormulaTreeNode(FormulaTreeNode node) {
		children.add(node);
	}

}

public class SimpleModelChecker implements ModelChecker {
	ArrayList<Formula> allFormulas = new ArrayList<Formula>();
	int depth = 0;
	Formula parentNode;
	Formula currNode;
	FormulaTree tree;
	public boolean check(Model model, Formula constraint, Formula formula) {
		// TO IMPLEMENT

		makeAllFormulas(formula);

		return false;
	}

	private void makeAllFormulas(Formula f) {
		ArrayList<Formula> childFormulas=new ArrayList<Formula>();
		FormulaTreeNode currTreeNode=null;
		if (currNode != null) {
			parentNode = currNode;
		}
		if (f.getNestedCTL().length != 0) {

			for (int i = 0; i < f.getNestedCTL().length; i++) {
				currNode = f.getNestedCTL()[i];
					if(currNode.getNestedCTL().length!=0){
						for(int j=0;j<currNode.getNestedCTL().length;j++){
								childFormulas.add(currNode.getNestedCTL()[j]);
						}
						currTreeNode =new FormulaTreeNode(currNode, parentNode, childFormulas); 
						childFormulas.clear();
					}
					else{
						currTreeNode=new FormulaTreeNode(currNode,parentNode, new ArrayList<Formula>());
					}
					if(currNode.equals(parentNode)){
					tree=new FormulaTree(currTreeNode);
					}
				makeAllFormulas(f.getNestedCTL()[i]);

			}
		}
		
		
		else {

			return;

		}

	}

	public String[] getTrace() {
		// TO IMPLEMENT
		return null;
	}
}

// procedure label-graph(f)
// begin
// . . .
// (main operator is AU)
// begin
// ST := empty-stack;
// for all s E S do marked(s) := false;
// L: forallsESdo
// if lmarked(s) then au( f, s, b)
// end
// . . .
// end

// procedure au( f, s, b)
// begin
// if marked(s) then
// begin
// if labeled@, f) then
// begin b := true; return end;
// b := false; return
// end;
// (Mark state s as visited. Let f = A[f, Uf2]. If f 2 is t rue at s, f is true
// at s; so label s with f
// and return true. If f, is not true at s, then f is not true at s; so return
// false.)
// marked(s) := true;
// if labeled(s, arg2( f)) then
// begin adhlabel(s, f); b := true; return end
// else if llabeled(s, argl(f)) then
// begin b := false; return end;
// push(s, ST);
// for all sl E successors(s) do
// begin
// df, sl, bl);
// if 311 then
// begin pop(ST); b := false; return end
// end;
// pop(ST); add-label(s, f); b := true; return
// end of procedure au.